#pragma rtGlobals=1		// Use modern global access method.



function insert_scine(length,diameter,Kpene,Kdeform,Neher, num, cond, k, alpha)
	//This outputs three waves containing the EEI area located in, along, and out of the cell
		//and calculates total seal resistance
	//electrode length in nanometers and rates of penetration/envelopment in units of (nm per step)


//first make determine the length in each state

	variable length
	variable diameter
	
	//this can be replaced by one parameter
	variable kpene            //relative rate of membrane penetration
	variable kdeform          //relative rate of envelopment
	
	
	variable Neher           //passed to another program see Rsheet()
	variable num           // number of compartments
	
	variable cond          //specific membrane conductance
	variable k             //cpe
	variable alpha       //cpe
	
	
	
	//initial values of length in nm in each state
	variable L_intra = 0
	variable L_env =0
	variable L_extra=length
	variable tmax = (length / (kpene+kdeform))+ 1


	//length waves
	make /o/n=(tmax) intra
	make /o/n=(tmax) extra
	make /o/n=(tmax) env

	//timer
	variable t =0

	do
		//penetration into neuron
		 L_intra = Kpene * t
		 intra[t]= L_intra
		//envelopment by neuron
		L_env = Kdeform * t
		env[t]= L_env
		// remaining extracellular 
		L_extra = length - (L_intra + L_env)
		extra[t]= L_extra
		
	t +=1
		
	while (L_extra > 0)

// next determine area in each state over time

	// surface area of end-cap
	variable cap = pi*(diameter*(1e-9)/2)^2

	//surface area per nm of sides
	variable side = pi*(diameter*(1e-9))*(1e-9)

	//intracellular area over time
	make /o/n=(tmax) A_intra
	A_intra[0]= 0
		t=1
		if (kpene == 0)
			A_intra=0
		else
			do
				A_intra[t]= cap + side*intra[t]
				t+=1
			while (t < tmax)
		endif
	//enveloped area over time
	make /o/n=(tmax) A_env
	A_env[0]= 0
		t=1
		do
			A_env[t]= side*env[t]
			t+=1
		while (t < tmax)
	//extracellular area over time
	make /o/n=(tmax) A_extra
	A_extra[0]= cap + length*side
		t=1
		do
			A_extra[t]= side*extra[t]
			t+=1
		while (t<tmax)

	//area of membrane envelopment (radius 50 nm larger than electrode) this is an approximation based on Braun and Fromherz 2004
	make /o/n=(tmax) A_membrane
	variable circum_mem = pi*((diameter+100)*(1e-9))*(1e-9)
	A_membrane[0]= 0
		t=1
		do
			A_membrane[t]= circum_mem*env[t]
			t+=1
		while (t < tmax)




// Now Call RSheet() and calculate the seal resistance based on the amount of enveloped membrane

RSheet(diameter, Neher, tmax, env)

//calculate values for compartments
compartmental(num, cond, k, alpha, tmax,A_membrane, A_env,  A_intra, A_extra, Rseal)


end








function Rsheet(diameter,Neher, tmax,env)

//1 Neher has units of restivity/thickness (ohms), an arbitrary unit of Neher is defined so that  a seal region of equal circumference and length has a resistance of 1 GOhm*, 
// where the sealing diameter is defined as the inner diameter of the seal region (the electrode diameter) -- a Neher is just a Gigaohm
// this variable is used to reflect the confounding uncertainty surrounding both the geometry and composition of the seal 
// for estimating the geometry of the membrane area surrounding the electrode, a seal region of thickness 50 nm is used (Braun and Fromherz 2004). 
//      *one example would be a 318 nm diameter nanopost enveloped by membrane for a length of 1 micron.


variable diameter
variable Neher
variable tmax
wave env

Neher *= 10^9
make /o/n=(tmax) Rseal

//calculate seal resistance over time

	variable t=0
	do
	Rseal[t]= Neher*env[t]/(diameter*pi)
	t +=1
	while (t < tmax)

end








//generates values for each comparemental variable 
function compartmental(num, cond, k, alpha, tmax,A_mem, A_env, A_intra, A_extra, Rseal)
variable num //number of discrete compartments
variable cond // membrane conductance per square micron in PS
variable k //cpe constant
variable alpha //cpe exponent
variable tmax //number of simulation steps

wave A_mem //area of membrane envelopment over time
wave A_env //area of  membrane-eneveloped electrode over time
wave A_intra // area of intracellular electrode
wave A_extra //area outside membrane
wave Rseal //total seal resistance over time

variable t //time


//calculate resistance between each compartment
	make /o/n=(tmax) Rseal_c = Rseal / num

	
//calculate compartmental membrane resistance	
	//calculate trans membrane conductance over time
	make /o/n=(tmax) Stm = cond * A_mem
	//divide by number of compartments
	stm /= num
	//calculate resistance
	make /o/n=(tmax) Rtm_c = stm^-1
	killwaves stm //kill temp wave

//calculate compartmental capacitance

	make /o/n=(tmax) Ctm_c= (A_mem * 0.01)/ num

//create compartmental cpe

	//stores 1 cpe for each time point in a tmax by 8000 matrix
	//remember that the frequency wave (fwave) contains the corresponding x values to be plotted against the cpe y values for each column in the matrix
	
	variable kscaled // k* area of electrode segment 
	variable count
	
	make /c/o/n=(8000,tmax) cpe_env
	cpe_env[][0]=1e100
	t=1
	do
		kscaled = k * (A_env[t]/num)
		cpe(alpha, kscaled, .001, 100000)
		wave cpe_z //initialize newly created wave
			count =0
			do
			cpe_env[count][t]= cpe_z[count]
			count +=1
			while (count < 8000)
		t+=1	
	while (t <tmax)

		
//create intracellular cpe

	make /c/o/n=(8000,tmax) cpe_intra 
	cpe_intra[][0]=1e100
	t=1
	do
		kscaled = k * (A_intra[t])
		cpe(alpha, kscaled, .001, 100000)
		wave cpe_z //initialize newly created wave
			count =0
			do
			cpe_intra[count][t]= cpe_z[count]
			count +=1
			while (count < 8000)
		t+=1	
	while (t <tmax)

//create extracellular cpe

make /c/o/n=(8000,tmax) cpe_extra
	cpe_extra[][7999]=1e100
	t=0
	do
		kscaled = k * (A_extra[t])
		cpe(alpha, kscaled, .001, 100000)
		wave cpe_z //initialize newly created wave
			count =0
			do
			cpe_extra[count][t]= cpe_z[count]
			count +=1
			while (count < 7999)
		t+=1	
	while (t <tmax)



end

















/////////////////////////////////////////////////////////playing with CPE



			function sweepk(kstart,kstop,a)
				//calls function cpe
				//sweep k constant on log scale for a given alpha

			variable kstart
			variable kstop
			variable a 

			variable k
			variable increment= (log(kstop)-log(kstart))/10           //
			variable f1= 0.001
			variable f2= 1e5
			variable i=log(kstart)         //initialize at 1

		
					//open graph
					make /c/o/n=1 blank= nan
					display /k=1 blank
					ModifyGraph log=1

			do
				cpe(a,10^i,f1,f2)
				i+= increment
				while (i < log(kstop))		//stop at alpha=1 (capacitor)


					//remove blank
					RemoveFromGraph blank


			end

			function sweepa(k)
				//calls function cpe
				//for a given constant, generate a ton of CPEs with varying alphas

			variable k 
			variable f1= 0.001
			variable f2= 1e5
			variable i=0         //initialize at aplha=0 (resistor)

		
					//open graph
					make /c/o/n=1 blank= nan
					display /k=1 blank
					ModifyGraph log=1

			do
				cpe(i,k,f1,f2)
				i+=.02
				while (i <1.02)		//stop at alpha=1 (capacitor)


					//remove blank
					RemoveFromGraph blank


			end


///////////////////////////////////////////////////////////////





function CPE(alpha,k,fstart,fstop)
	//produces a constant phase element with freq dependence 1/ (f^alpha) and constant k
	//here k incluces the specific capacitance at 1 Hz (Cspec) times the electrode area
	
variable alpha
variable k
variable fstart
variable fstop
variable f
variable z
variable points 
variable /c im = (-1)^.5

points = (log(fstop)-log(fstart))*1000

//make xwave for log(frequency) with 1k points per decade
	make /o/n=2 xwave
	xwave[0] =log(fstart)
	xwave[1] =log(fstop)
	Interpolate2/T=1/N=(points)/Y=xwave_L xwave
	duplicate /o xwave_L, xwave
	killwaves xwave_L


//make a frequency wave to plot against the cpe
	make /o/n=(points) fwave
	variable i=0
	variable x
	do
		x = xwave[i]
		fwave[i] = 10^x
		i += 1
	while (i < points)

// make a constant phase element with impedance at frequencies "fwave"

	make  /o/c/n=(points) cpe_Z
	i=0
	do
		x=fwave[i]
		cpe_z[i]= 1 / (k*(x*im)^alpha)
		i +=1
	while (i < points)

//rename output wave, kill temp files, and display all CPEs

	//this old naming system was more informative before I made the cpe function a sub-function to insert_scine
		//string output = "CPE_k=" + num2str(k) + "a=" +num2str(alpha)
		//duplicate /o cpe_z $(output)
		//killwaves cpe_z, xwave

	//	killwaves xwave

	//now defunct graphing
		//AppendToGraph $(output) vs fwave
	//	SetAxis bottom (fstart), (fstop)
	//	ModifyGraph cmplxMode=3

end